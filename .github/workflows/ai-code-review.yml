name: AI Code Review

on:
  pull_request:
    types: [opened, reopened, review_requested, ready_for_review, synchronize]

jobs:
  review:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: AI Code Review
        env:
          # Required: API endpoint for the code review service
          API_ENDPOINT: ${{ secrets.AI_REVIEW_API_ENDPOINT }}
          # Optional: API key for the AI provider (if not provided, server-side keys will be used)
          # Recommended to set this if your API endpoint doesn't have server-side keys configured
          AI_API_KEY: ${{ secrets.AI_API_KEY }}
          # Optional: AI provider (defaults to 'openai' if not set)
          # Use 'vercel-ai-gateway' to use Vercel AI Gateway
          AI_PROVIDER: ${{ secrets.AI_PROVIDER }}
          # Optional: Specific model to use (uses provider default if not set)
          AI_MODEL: ${{ secrets.AI_MODEL }}
          # Optional: Fallback models for Vercel AI Gateway (comma-separated list)
          # Example: "openai/gpt-4,anthropic/claude-3-opus"
          AI_FALLBACK_MODELS: ${{ secrets.AI_FALLBACK_MODELS }}
          # GITHUB_TOKEN is automatically provided by GitHub Actions - no need to set it as a secret
          # It's available as ${{ secrets.GITHUB_TOKEN }} or via the GITHUB_TOKEN environment variable
        run: |
          # Get PR information (define early for use throughout workflow)
          PR_URL="${{ github.event.pull_request.html_url }}"
          PR_NUMBER="${{ github.event.pull_request.number }}"
          REPO_OWNER="${{ github.repository_owner }}"
          REPO_NAME="${{ github.event.repository.name }}"
          GITHUB_TOKEN="${{ secrets.GITHUB_TOKEN }}"
          
          # Validate required variables
          if [ -z "$PR_NUMBER" ] || [ -z "$REPO_OWNER" ] || [ -z "$REPO_NAME" ]; then
            echo "::error::Missing required PR information: PR_NUMBER=$PR_NUMBER, REPO_OWNER=$REPO_OWNER, REPO_NAME=$REPO_NAME"
            exit 1
          fi

          # Set defaults if not provided
          AI_PROVIDER="${AI_PROVIDER:-openai}"

          echo "Reviewing PR: $PR_URL"
          echo "Using provider: $AI_PROVIDER"

          # Prepare request payload
          # Note: apiKey is optional - if not provided, the API will use server-side stored keys
          # For GitHub Actions, it's recommended to provide the API key via secrets
          # Build base payload
          BASE_PAYLOAD=$(cat <<EOF
          {
            "messages": [
              {
                "role": "user",
                "content": "Please review this pull request: $PR_URL"
              }
            ],
            "provider": "$AI_PROVIDER",
            "stream": false
          }
          EOF
          )

          # Add apiKey if provided
          if [ -n "$AI_API_KEY" ]; then
            BASE_PAYLOAD=$(echo "$BASE_PAYLOAD" | jq --arg key "$AI_API_KEY" '. + {"apiKey": $key}')
          fi

          # Add model if provided
          if [ -n "$AI_MODEL" ]; then
            BASE_PAYLOAD=$(echo "$BASE_PAYLOAD" | jq --arg model "$AI_MODEL" '. + {"model": $model}')
          fi

          # Add fallbackModels if provided (for Vercel AI Gateway)
          if [ -n "$AI_FALLBACK_MODELS" ]; then
            # Convert comma-separated string to JSON array
            FALLBACK_ARRAY=$(echo "$AI_FALLBACK_MODELS" | jq -R -s -c 'split(",") | map(select(length > 0) | gsub("^\\s+|\\s+$"; ""))')
            BASE_PAYLOAD=$(echo "$BASE_PAYLOAD" | jq --argjson fallbacks "$FALLBACK_ARRAY" '. + {"fallbackModels": $fallbacks}')
          fi

          REQUEST_PAYLOAD="$BASE_PAYLOAD"

          # Call the AI code review API (non-streaming)
          echo "Calling API endpoint: $API_ENDPOINT"
          echo "Request payload: $(echo "$REQUEST_PAYLOAD" | jq -c .)"

          # Use curl with better error handling
          HTTP_CODE=$(curl -s -o /tmp/response.json -w "%{http_code}" -X POST "$API_ENDPOINT" \
            -H "Content-Type: application/json" \
            -d "$REQUEST_PAYLOAD")

          REVIEW_RESPONSE=$(cat /tmp/response.json)

          echo "HTTP Status Code: $HTTP_CODE"
          echo "Response (first 500 chars): ${REVIEW_RESPONSE:0:500}"

          # Check HTTP status code
          if [ "$HTTP_CODE" -lt 200 ] || [ "$HTTP_CODE" -ge 300 ]; then
            echo "::error::API returned HTTP $HTTP_CODE"
            echo "Full response: $REVIEW_RESPONSE"
            
            # Try to extract error details
            if echo "$REVIEW_RESPONSE" | jq -e '.error' > /dev/null 2>&1; then
              ERROR_MSG=$(echo "$REVIEW_RESPONSE" | jq -r '.error')
              ERROR_DETAILS=$(echo "$REVIEW_RESPONSE" | jq -r '.details // empty')
              
              echo "::error::Error: $ERROR_MSG"
              if [ -n "$ERROR_DETAILS" ] && [ "$ERROR_DETAILS" != "null" ]; then
                echo "Error details: $ERROR_DETAILS"
              fi
              
              # Provide helpful suggestions based on error type
              if echo "$ERROR_MSG" | grep -qi "Method Not Allowed"; then
                echo "::warning::This error usually indicates:"
                echo "  1. The AI provider API key may be invalid or expired"
                echo "  2. The model specified may not be available or supported"
                echo "  3. For Vercel AI Gateway: Check that your API key has access to the requested models"
                echo "  4. For Vercel AI Gateway: Verify fallback models are in correct format (e.g., 'deepseek/deepseek-coder')"
              fi
            fi
            
            exit 1
          fi

          # Check if response is empty
          if [ -z "$REVIEW_RESPONSE" ]; then
            echo "::error::Empty response from API"
            exit 1
          fi

          # Check if response is valid JSON
          if ! echo "$REVIEW_RESPONSE" | jq . > /dev/null 2>&1; then
            echo "::error::Invalid JSON response from API"
            echo "Response: $REVIEW_RESPONSE"
            exit 1
          fi

          # Check if the API call returned an error
          if echo "$REVIEW_RESPONSE" | jq -e '.error' > /dev/null 2>&1; then
            ERROR_MSG=$(echo "$REVIEW_RESPONSE" | jq -r '.error')
            ERROR_DETAILS=$(echo "$REVIEW_RESPONSE" | jq -r '.details // empty')
            
            echo "::error::Error from API: $ERROR_MSG"
            if [ -n "$ERROR_DETAILS" ] && [ "$ERROR_DETAILS" != "null" ]; then
              echo "Error details: $ERROR_DETAILS"
            fi
            
            # Provide helpful suggestions based on error type
            if echo "$ERROR_MSG" | grep -qi "Method Not Allowed"; then
              echo "::warning::Troubleshooting 'Method Not Allowed' error:"
              echo "  - Verify your AI_API_KEY secret is correct and has proper permissions"
              echo "  - Check that the model ($AI_MODEL) is available for provider ($AI_PROVIDER)"
              echo "  - For Vercel AI Gateway: Ensure your API key has access to the gateway"
              echo "  - For Vercel AI Gateway: Verify fallback models format is correct"
              echo "  - Try using a different provider or model"
            fi
            
            exit 1
          fi

          # Extract the review text and usage from the response
          # The API returns { text: "...", usage: {...} } for non-streaming
          REVIEW_TEXT=$(echo "$REVIEW_RESPONSE" | jq -r '.text // empty')
          USAGE=$(echo "$REVIEW_RESPONSE" | jq '.usage // empty')

          if [ -z "$REVIEW_TEXT" ] || [ "$REVIEW_TEXT" = "null" ]; then
            echo "Error: No review content received"
            echo "Full response: $REVIEW_RESPONSE"
            echo "Response structure: $(echo "$REVIEW_RESPONSE" | jq 'keys')"
            exit 1
          fi

          # Post comment to GitHub PR using GitHub API
          if [ -n "$GITHUB_TOKEN" ]; then
            echo "Posting review comment to PR #$PR_NUMBER..."
            
            # Build comment body with unique marker for potential future deduplication
            # Use printf to properly handle newlines in markdown
            COMMENT_BODY=$(printf "## ðŸ¤– AI Code Review\n\n<!-- ai-code-review-bot -->\n\n%s" "$REVIEW_TEXT")
            
            # Add usage information if available
            if [ "$USAGE" != "null" ] && [ -n "$USAGE" ]; then
              PROMPT_TOKENS=$(echo "$USAGE" | jq -r '.promptTokens // .prompt_tokens // 0')
              COMPLETION_TOKENS=$(echo "$USAGE" | jq -r '.completionTokens // .completion_tokens // 0')
              TOTAL_TOKENS=$(echo "$USAGE" | jq -r '.totalTokens // .total_tokens // 0')
              
              if [ "$TOTAL_TOKENS" != "0" ] && [ "$TOTAL_TOKENS" != "null" ]; then
                COMMENT_BODY=$(printf "%s\n\n---\n**Usage:** %s prompt + %s completion = %s tokens" "$COMMENT_BODY" "$PROMPT_TOKENS" "$COMPLETION_TOKENS" "$TOTAL_TOKENS")
              fi
            fi
            
            # Check for existing bot comment and update if found, otherwise create new
            EXISTING_COMMENT_ID=$(curl -s \
              -H "Authorization: Bearer $GITHUB_TOKEN" \
              -H "Accept: application/vnd.github.v3+json" \
              -H "User-Agent: my-ai-app/ai-code-review" \
              "https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/issues/$PR_NUMBER/comments" \
              | jq -r '.[] | select(.body | contains("<!-- ai-code-review-bot -->")) | .id' | head -n1)
            
            COMMENT_JSON_BODY=$(echo "$COMMENT_BODY" | jq -Rs .)
            
            if [ -n "$EXISTING_COMMENT_ID" ] && [ "$EXISTING_COMMENT_ID" != "null" ]; then
              echo "Updating existing comment (ID: $EXISTING_COMMENT_ID)..."
              COMMENT_RESPONSE=$(curl -s -w "\n%{http_code}" -X PATCH \
                "https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/issues/comments/$EXISTING_COMMENT_ID" \
                -H "Authorization: Bearer $GITHUB_TOKEN" \
                -H "Accept: application/vnd.github.v3+json" \
                -H "Content-Type: application/json" \
                -H "User-Agent: my-ai-app/ai-code-review" \
                -d "{\"body\": $COMMENT_JSON_BODY}")
            else
              echo "Creating new comment..."
              COMMENT_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
                "https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/issues/$PR_NUMBER/comments" \
                -H "Authorization: Bearer $GITHUB_TOKEN" \
                -H "Accept: application/vnd.github.v3+json" \
                -H "Content-Type: application/json" \
                -H "User-Agent: my-ai-app/ai-code-review" \
                -d "{\"body\": $COMMENT_JSON_BODY}")
            fi
            
            COMMENT_HTTP_CODE=$(echo "$COMMENT_RESPONSE" | tail -n1 | tr -d '[:space:]')
            COMMENT_BODY_RESPONSE=$(echo "$COMMENT_RESPONSE" | sed '$d')
            
            # Handle specific HTTP status codes
            case "$COMMENT_HTTP_CODE" in
              200|201)
                echo "âœ… Successfully posted review comment to PR #$PR_NUMBER"
                ;;
              403)
                echo "::error::Failed to post PR comment: Forbidden (HTTP 403)"
                echo "This usually indicates:"
                echo "  - Rate limit exceeded (check GitHub API rate limits)"
                echo "  - Insufficient permissions for GITHUB_TOKEN"
                echo "  - Token has expired or been revoked"
                echo "Comment response: $COMMENT_BODY_RESPONSE"
                ;;
              404)
                echo "::error::Failed to post PR comment: Not Found (HTTP 404)"
                echo "This usually indicates:"
                echo "  - PR #$PR_NUMBER not found in $REPO_OWNER/$REPO_NAME"
                echo "  - Repository or issue doesn't exist"
                echo "  - GITHUB_TOKEN doesn't have access to this repository"
                echo "Comment response: $COMMENT_BODY_RESPONSE"
                ;;
              422)
                echo "::error::Failed to post PR comment: Validation Error (HTTP 422)"
                echo "This usually indicates:"
                echo "  - Comment body is too long or contains invalid characters"
                echo "  - PR is locked or in a state that doesn't allow comments"
                echo "Comment response: $COMMENT_BODY_RESPONSE"
                ;;
              *)
                if [ "$COMMENT_HTTP_CODE" -ge 200 ] && [ "$COMMENT_HTTP_CODE" -lt 300 ]; then
                  echo "âœ… Successfully posted review comment to PR #$PR_NUMBER"
                else
                  echo "::warning::Failed to post PR comment (HTTP $COMMENT_HTTP_CODE)"
                  echo "Comment response: $COMMENT_BODY_RESPONSE"
                  echo "Review was still generated successfully, but comment was not posted."
                fi
                ;;
            esac
          else
            echo "Review completed! (No GitHub token available, comment not posted)"
          fi
